---
title: "Effect of character correlation"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

Effect of character correlation
===============


Loading the functions and the data
-----------------------------------

Getting the functions and the data.

```{r, eval = TRUE, message = FALSE}
library(knitr)
library(dispRity)
library(lme4)
library(lmerTest)
source("functions.R") ; load.functions(test = FALSE)
dyn.load("../Functions/char.diff.so")
load("../Data/NTS/matrix.nts.Rda")
source("../Data/load.data.R")

## Getting the whole data
whole_data <- list("t25" = t25_list, "t75" = t75_list, "t150" = t150_list)
```

Pooled results
=================

Effect of character correlation per scenario
-----------------

```{r}
## Pulling the data per scenario
max_RF_norm <- pool.distribution(whole_data, param = "maxi", metric = "RF", best = "norm")
min_RF_norm <- pool.distribution(whole_data, param = "mini", metric = "RF", best = "norm")
rand_RF_norm <- pool.distribution(whole_data, param = "rand", metric = "RF", best = "norm")
scenario_RF_norm <- matrix(data = c(max_RF_norm, min_RF_norm, rand_RF_norm),
                           ncol = 3, dimnames = list(c(), c("max", "min", "rand")))

max_RF_null <- pool.distribution(whole_data, param = "maxi", metric = "RF", best = "rand")
min_RF_null <- pool.distribution(whole_data, param = "mini", metric = "RF", best = "rand")
rand_RF_null <- pool.distribution(whole_data, param = "norm", metric = "RF", best = "rand")
scenario_RF_null <- matrix(data = c(max_RF_null, min_RF_null, rand_RF_null),
                           ncol = 3, dimnames = list(c(), c("max", "min", "norm")))

max_Tr_norm <- pool.distribution(whole_data, param = "maxi", metric = "Tr", best = "norm")
min_Tr_norm <- pool.distribution(whole_data, param = "mini", metric = "Tr", best = "norm")
rand_Tr_norm <- pool.distribution(whole_data, param = "rand", metric = "Tr", best = "norm")
scenario_Tr_norm <- matrix(data = c(max_Tr_norm, min_Tr_norm, rand_Tr_norm),
                           ncol = 3, dimnames = list(c(), c("max", "min", "rand")))

max_Tr_null <- pool.distribution(whole_data, param = "maxi", metric = "Tr", best = "rand")
min_Tr_null <- pool.distribution(whole_data, param = "mini", metric = "Tr", best = "rand")
rand_Tr_null <- pool.distribution(whole_data, param = "norm", metric = "Tr", best = "rand")
scenario_Tr_null <- matrix(data = c(max_Tr_null, min_Tr_null, rand_Tr_null),
                           ncol = 3, dimnames = list(c(), c("max", "min", "norm")))


op <- par(mfrow = c(2,2))#, mar = c(2, 4, 1, 2))
cols <- c("red", "orange", "green3", "lightgreen", "blue", "lightblue")


boxplot(scenario_RF_norm, las = 1, horizontal = TRUE, xlab = "")



plot.results.single(t25_list, metric = 2, what = "best",
    legend = TRUE, NTS = TRUE, xlab = "", ylab = "RF for 25 taxa",
    axislab = FALSE)
plot.results.single(t75_list, metric = 2, what = "best", ylab = "RF for 75 taxa",
    xlab = "", axislab = FALSE, NTS = TRUE)
plot.results.single(t150_list, metric = 2, what = "best",
    ylab = "RF for 150 taxa", NTS = TRUE)
par(op)


boxplot(scenario_RF_norm, col = )
```


Effect of character correlation per number of character
-----------------


Effect of character correlation per number of taxa
-----------------


Effect of character correlation per methods
-----------------


Individual results
=================

We can also analyse the effect of each parameters combination separately:

Summary statistics
-----------------

We can also apply a non-parametric pairwise comparison between scenarios for each parameters combinations.
Note however that the resulting p-values are not always exact due to ties in the results (again, due to the metric being bounded to 1).
The p-values are adjusted for multiple tests using Bonferroni-Holm correction.

```{r}
## Running the pairwise Wilcox tests:
sum_RF_best <- apply.test(whole_data, "RF", "norm", NULL)
sum_Tr_best <- apply.test(whole_data, "Triples", "norm", NULL)
sum_RF_null <- apply.test(whole_data, "RF", "null", NULL)
sum_Tr_null <- apply.test(whole_data, "Triples", "null", NULL)
```

```{r, echo = FALSE}
## Setting the table captions
captions_summary <- paste("Summary statistics of the normalised", rep(c("Robinson-Fould", "Triplets"), 2), "distance to the", c(rep("best", 2), rep("null", 2)), "tree.")

## Printing the tables
kable(sum_RF_best, row.names = FALSE, caption = captions_summary[1])
kable(sum_Tr_best, row.names = FALSE, caption = captions_summary[2])
kable(sum_RF_null, row.names = FALSE, caption = captions_summary[3])
kable(sum_Tr_null, row.names = FALSE, caption = captions_summary[4])
```

<!-- Table for publication -->

```{r, echo = FALSE, eval = FALSE}
library(xtable)
## Wrapper function
make.xtable <- function(table, digit = 3, caption, label, longtable = FALSE) {
  
  table <- xtable(table, digit = digit, caption = caption, label = label)

  if(longtable == TRUE) {
    print(table, tabular.environment = 'longtable', floating = FALSE, include.rownames = FALSE)
  } else {
    print(table, include.rownames = FALSE)
  }
}

## Labels
labels_summary <- paste0("Tab_Summary", rep(c("RF", "Tr"), 2), c(rep("best", 2), rep("null", 2)))

## Tables
make.xtable(sum_RF_best, caption = captions_summary[1], label = labels_summary[1])
make.xtable(sum_Tr_best, caption = captions_summary[2], label = labels_summary[2])
make.xtable(sum_RF_null, caption = captions_summary[3], label = labels_summary[3])
make.xtable(sum_Tr_null, caption = captions_summary[4], label = labels_summary[4])
```

Nested anova
-----------------------------------

Let's analysis the data using a nested anova.
The models look at the effect of our scenarios ("maximised", "minimised", etc...) on the normalised tree score (NTS - using both the Robinson-Fould and Triplets scores) with a nested effect of the method (parsimony or bayesian), the number of taxa (25, 75, 150) and the number of characters (100, 150, 1000).

```{r}
## getting the aov data
aov_data_RF_best <- get.aov.data(whole_data, "RF", "norm", combined = TRUE)
aov_data_Tr_best <- get.aov.data(whole_data, "Triples", "norm", combined = TRUE)
aov_data_RF_null <- get.aov.data(whole_data, "RF", "null", combined = TRUE)
aov_data_Tr_null <- get.aov.data(whole_data, "Triples", "null", combined = TRUE)


## Models with normalised tree score function of scenario (with nestedness)
model_RF_best <- lmer(NTS ~ scenario + (1|method) + (1|taxa) + (1|character),
                      data = aov_data_RF_best)
model_Tr_best <- lmer(NTS ~ scenario + (1|method) + (1|taxa) + (1|character),
                      data = aov_data_Tr_best)
model_RF_null <- lmer(NTS ~ scenario + (1|method) + (1|taxa) + (1|character),
                      data = aov_data_RF_null)
model_Tr_null <- lmer(NTS ~ scenario + (1|method) + (1|taxa) + (1|character),
                      data = aov_data_Tr_null)

## Testing model assumptions
## Normality of the residuals
norm_RF_best <- shapiro.test(residuals(model_RF_best))
norm_Tr_best <- shapiro.test(residuals(model_Tr_best))
norm_RF_null <- shapiro.test(residuals(model_RF_null))
norm_Tr_null <- shapiro.test(residuals(model_Tr_null))
normality <- list(norm_RF_best, norm_Tr_best, norm_RF_null, norm_Tr_null)

## Variance homoscedasticity
homo_RF_best <- bartlett.test(NTS ~ scenario, data = aov_data_RF_best)
homo_Tr_best <- bartlett.test(NTS ~ scenario, data = aov_data_Tr_best)
homo_RF_null <- bartlett.test(NTS ~ scenario, data = aov_data_RF_null)
homo_Tr_null <- bartlett.test(NTS ~ scenario, data = aov_data_Tr_null)
homoscedasticity <- list(homo_RF_best, homo_Tr_best, homo_RF_null, homo_Tr_null)

# ## Summarise the results
results <- t(rbind(sapply(normality, function(x) x[c(1,2)]), 
                   sapply(homoscedasticity, function(x) x[c(1,2,3)])))
results <- matrix(as.numeric(results), ncol = 5)
colnames(results) <- c("W", "p.value", "Bartlett's K^2", "df", "p.value")
rownames(results) <- c("RF best", "Triples best", "RF null", "Triples null")
results <- round(results, 3)

# ## Check assumption's validities
check.validity <- function(X) {ifelse(X[2] >= 0.05 && X[5] >= 0.05, TRUE, FALSE)}
validity <- apply(results, 1, check.validity)

## Report results
results <- cbind(as.data.frame(results), validity)
```

```{r, echo = FALSE}
kable(results, caption = "Normality and variance homoscedasticity tests for anova.", digit = 3)
```

<!-- Table for publication -->

```{r, eval = FALSE, echo = FALSE}
xtable(results, caption = "Normality and variance homoscedasticity tests for anova.", digit = 2, label = "Tab_signif")
```


All our models violate a least one of the two models assumptions (normality of the residuals and homoscedasticity of variance) and thus cannot be used to compare the scenarios.
This is due to the fact that the metric is bounded to 1.

Distributions probability overlap (Bhattacharrya Coefficient)
-----------------------------------

We can also look at the effect of each scenario within each parameter setting (e.g. 25 taxa, 100 characters and Bayesian trees) by measuring the probability of overlap between both distributions.
A probability of overlap probability below 0.05 means the two scenario gives a distribution of tree scores that don t overlap (significant effect of one scenario on topology).
Conversely, an overlap probability above 0.95 means the two scenario gives the same tree scores (significant no effect of one scenario on topology).

```{r}
## Running the pairwise Bhattacharrya Coefficient analysis:
bc_RF_best <- apply.test(whole_data, "RF", "norm", bhatt.coeff)
bc_Tr_best <- apply.test(whole_data, "Triples", "norm", bhatt.coeff)
bc_RF_null <- apply.test(whole_data, "RF", "null", bhatt.coeff)
bc_Tr_null <- apply.test(whole_data, "Triples", "null", bhatt.coeff)

## Tables
kable(bc_RF_best, row.names = FALSE, digit = 3)
kable(bc_RF_best, row.names = FALSE, digit = 3)
kable(bc_RF_best, row.names = FALSE, digit = 3)
kable(bc_RF_best, row.names = FALSE, digit = 3)
```


```{r, echo = FALSE}
## Setting the table captions
captions_bc <- paste0("Bhattacharrya Coefficient (",rep(c("Robinson-Fould distance", "Triplets distance"), 2) ," from the ",c(rep("best", 2), rep("null", 2)), " tree)" , " between the different scenarios.")

## Printing the tables
kable(bc_RF_best, row.names = FALSE, caption = captions_bc[1], digit = 3)
kable(bc_Tr_best, row.names = FALSE, caption = captions_bc[2], digit = 3)
kable(bc_RF_null, row.names = FALSE, caption = captions_bc[3], digit = 3)
kable(bc_Tr_null, row.names = FALSE, caption = captions_bc[4], digit = 3)
```

<!-- Table for publication -->

```{r, echo = FALSE, eval = FALSE}
## Labels
labels_bc <- paste0("Tab_BC", rep(c("RF", "Tr"), 2), c(rep("best", 2), rep("null", 2)))

## Tables
make.xtable(bc_RF_best, caption = captions_bc[1], label = labels_bc[1])
make.xtable(bc_Tr_best, caption = captions_bc[2], label = labels_bc[2])
make.xtable(bc_RF_null, caption = captions_bc[3], label = labels_bc[3])
make.xtable(bc_Tr_null, caption = captions_bc[4], label = labels_bc[4])
```


Non-parametric pairwise comparisons
-----------------------------------

We can also apply a non-parametric pairwise comparison between scenarios for each parameters combinations.
Note however that the resulting p-values are not always exact due to ties in the results (again, due to the metric being bounded to 1).
The p-values are adjusted for multiple tests using Bonferroni-Holm correction.

```{r, warning = FALSE}
## Running the pairwise Wilcox tests:
wx_RF_best <- apply.test(whole_data, "RF", "norm", wilcox.test)
wx_Tr_best <- apply.test(whole_data, "Triples", "norm", wilcox.test)
wx_RF_null <- apply.test(whole_data, "RF", "null", wilcox.test)
wx_Tr_null <- apply.test(whole_data, "Triples", "null", wilcox.test)

## Applying Bonferroni correction
for(column in c(5,7,9)) {
  wx_RF_best[,column] <- p.adjust(wx_RF_best[,column], method = "bonferroni")
  wx_Tr_best[,column] <- p.adjust(wx_Tr_best[,column], method = "bonferroni")
  wx_RF_null[,column] <- p.adjust(wx_RF_null[,column], method = "bonferroni")
  wx_Tr_null[,column] <- p.adjust(wx_Tr_null[,column], method = "bonferroni")
}
```

```{r, echo = FALSE}
## Setting the table captions
captions_wx <- paste0("Non-parametric Wilcoxon test (",rep(c("Robinson-Fould distance", "Triplets distance"), 2) ," from the ",c(rep("best", 2), rep("null", 2)), " tree)" , " between the different scenarios (p-values corrected using Bonferroni-Holm correction).")

## Printing the tables
kable(wx_RF_best, row.names = FALSE, caption = captions_wx[1], digit = 3)
kable(wx_Tr_best, row.names = FALSE, caption = captions_wx[2], digit = 3)
kable(wx_RF_null, row.names = FALSE, caption = captions_wx[3], digit = 3)
kable(wx_Tr_null, row.names = FALSE, caption = captions_wx[4], digit = 3)
```

<!-- Table for publication -->

```{r, echo = FALSE, eval = FALSE}
## Labels
labels_wx <- paste0("Tab_BC", rep(c("RF", "Tr"), 2), c(rep("best", 2), rep("null", 2)))

## Tables
make.xtable(wx_RF_best, caption = captions_wx[1], label = labels_wx[1])
make.xtable(wx_Tr_best, caption = captions_wx[2], label = labels_wx[2])
make.xtable(wx_RF_null, caption = captions_wx[3], label = labels_wx[3])
make.xtable(wx_Tr_null, caption = captions_wx[4], label = labels_wx[4])
```